---
layout: post
title: "MySQL5からのインデックス結合で１テーブル複数インデックスを使う"
---
{% raw %}
komagataです。<br /><br />Webアプリケーションのパフォーマンスの大半はデータベース、特にインデックスの使われ方にかかっている気がします。<br /><br />仕事でもMySQLをよく使いますが、MySQLでは１テーブルに付き１インデックスしか使われません。PostgreSQLなどと比べてそのことが気になってMySQLでのパフォーマンスチューニングに全く自信が持てませんでした。<br /><br />オライリーの<a href="http://www.oreilly.co.jp/books/4873112095/">実践ハイパフォーマンスMySQL</a>には下記のように書かれています。<br /><br /><blockquote>実際、UNIONを除き、MySQLでは、１つのクエリを実行するとき、１つのテーブルに付き１つのインデックスしか使用できない。<strong>この事実は、繰り返し述べるに値するほど重要である</strong>。「<strong>MySQLでは、１つのクエリを実行するとき、１つのテーブルにつき１つのインデックスしか使用できないのである</strong>。」</blockquote><br /><br />また、その制約を考えたクエリの書き方として下記の様に書いてあります。<br /><br /><blockquote><pre>mysql&gt; EXPLAIN SELECT * FROM Headline<br />    -&gt; WHERER ExpireTime &gt;= 1012201600 OR Id &lt;= 5000000<br />    -&gt; ORDER BY ExpireTime ASC LIMIT 10\G</pre><br /><br />何と、MySQLは完全なテーブルスキャンを実行すべきだと判断してしまった。（中略）このようなクエリを、UNIONを使用して書き換えることができる。そのためには、クエリを２つのクエリに分解し、それぞれのクエリで１つのインデックスを使用する。その後で、結果を結合してソートする。つまり、以下のようなクエリを実行すればよい。<br /><br /><pre>(SELECT * FROM Headline WHERE ExpireTime &gt;= 1081020749<br />ORDER BY ExpireTime ASC LIMIT 10)<br /> <br />UNION<br /> <br />(SELECT * FROM Headline WHERE Id &lt;= 50000<br />ORDER BY ExpireTime ASC LIMIT 10)<br /> <br />ORDER BY ExpireTime ASC LIMIT 10<pre></blockquote><br /><br />こんな簡単なクエリでわざわざこんなことしなくちゃいけないのかよと思いました・・・。<br /><br />しかし本書はMySQL 4.0.14をベースにかかれていています。MySQLユーザー的には常識なのかもしれませんがMySQL 5.0からはインデックス結合という機能があるそうです。１テーブル１インデックス問題（勝手にそう呼んでいる）が解決するかもしれないと思って調べてみました。<br /><br />インデックス結合とはその名の通り複数のインデックスを結合して結果を返してくれるそうです。EXPLAINのtypeフィールドではindex_mergeというメソッド名で表されます。<br /><br /><a href="http://dev.mysql.com/doc/refman/5.1/ja/index-merge-optimization.html">マニュアル</a>に拠ればインデックス結合には3つのアルゴリズムがありそれぞれEXPLAINのExrtaフィールドで確認できます。（Using～というやつ）<br /><br />そしてそれぞれのアルゴリズムは下記のような時に選ばれるそうです。<br /><br /><ul><br /><li>共通集合アルゴリズム --- Using intersect(...)<br /><br />WHERE節で異なるインデックスをANDでつないだ時。</li><br /><li>ユニオンアクセスアルゴリズム --- Using union(...)<br /><br />WHERE節で異なるインデックスをORでつないだ時。</li><br /><li>ソートユニオンアクセスアルゴリズム --- Using sort_union(...)<br /><br />WHERE節で異なるインデックスをORでつないだ時でソートが必要な時。（前述のUNIONしなければならない例はこれに該当するんじゃないでしょうか）</li><br /></ul><br /><br />結合方法自体OPTIMIZERが選択するので必ず使われるわけではありません。<br />実際の効果の程を試してみました。<br /><br />試した環境：<br /><br />Debian etch<br />MySQL 4.1.22, MySQL 5.0.32<br /><br />テーブル：<br /><br /><pre class="code">CREATE TABLE `employees` (<br />  `id` int(11) NOT NULL auto_increment,<br />  `name` varchar(32) default NULL,<br />  `age` int(11) default NULL,<br />  PRIMARY KEY  (`id`),<br />  KEY `index_name` (`name`),<br />  KEY `index_age` (`age`)<br />)</pre><br /><br />テストデータ（ランダムなデータ10万件)：<br /><br /><pre class="code">#!/usr/bin/env ruby<br /> <br />100000.times do |i|<br />  puts "INSERT INTO employees (name, age) VALUES ('name_#{rand(100)}', #{rand(100)});"<br />end</pre><br /><br /><br />テストデータを投入し、ANALYZE TABLEした後のインデックスは下記の通りです。<br /><br /><pre class="code">mysql&gt; SHOW INDEX FROM employees\G<br />*************************** 1. row ***************************<br />       Table: employees<br />  Non_unique: 0<br />    Key_name: PRIMARY<br />Seq_in_index: 1<br /> Column_name: id<br />   Collation: A<br /> Cardinality: 160673<br />    Sub_part: NULL<br />      Packed: NULL<br />        Null:<br />  Index_type: BTREE<br />     Comment:<br />*************************** 2. row ***************************<br />       Table: employees<br />  Non_unique: 1<br />    Key_name: index_name<br />Seq_in_index: 1<br /> Column_name: name<br />   Collation: A<br /> Cardinality: 53557<br />    Sub_part: NULL<br />      Packed: NULL<br />        Null: YES<br />  Index_type: BTREE<br />     Comment:<br />*************************** 3. row ***************************<br />       Table: employees<br />  Non_unique: 1<br />    Key_name: index_age<br />Seq_in_index: 1<br /> Column_name: age<br />   Collation: A<br /> Cardinality: 99<br />    Sub_part: NULL<br />      Packed: NULL<br />        Null: YES<br />  Index_type: BTREE<br />     Comment:<br />3 rows in set (0.00 sec)</pre><br /><br />この条件でMySQL 4.1.22, 5.0.32それぞれで上記のアルゴリズムが使われた場合（5.0.32）と使われない場合（4.1.22）でEXPLAIN結果と速度を計りました。<br /><br />・共通集合アルゴリズム<br /><br />MySQL 4.1.22の場合：<br /><br /><pre class="code">mysql&gt; EXPLAIN SELECT * FROM employees WHERE name = "name_1" AND age = 1\G<br />*************************** 1. row ***************************<br />           id: 1<br />  select_type: SIMPLE<br />        table: employees<br />         type: ref<br />possible_keys: index_name,index_age<br />          key: index_name<br />      key_len: 33<br />          ref: const<br />         rows: 571<br />        Extra: Using where<br />1 row in set (0.00 sec)</pre><br /><br />普通にインデックスが一つだけ使われました。<br /><br />MySQL 5.0.32の場合：<br /><br /><pre class="code">mysql&gt; EXPLAIN SELECT * FROM employees WHERE `name` = 'name_1' AND `age` = 1\G<br />*************************** 1. row ***************************<br />           id: 1<br />  select_type: SIMPLE<br />        table: employees<br />         type: index_merge<br />possible_keys: index_name,index_age<br />          key: index_age,index_name<br />      key_len: 5,99<br />          ref: NULL<br />         rows: 5<br />        Extra: Using intersect(index_age,index_name); Using where<br />1 row in set (0.01 sec)</pre><br /><br />typeにindex_merge、ExtraにUsing intersect(index_age,index_name)と出ました。共通集合アルゴリズムを使って別々のインデックスがマージされて使われているようです。<br /><br />実際の速度：<br /><br /><pre class="code">mysql&gt; SELECT SQL_NO_CACHE * FROM employees WHERE `name` = 'name_1' AND `age` = 1;</pre><br /><br />インデックス結合無し（MySQL 4.1.22）：0.01 sec<br />インデックス結合有り（MySQL 5.0.32）：0.01 sec<br /><br />・ユニオンアクセスアルゴリズム<br /><br />MySQL 4.1.22の場合：<br /><br /><pre class="code">mysql&gt; EXPLAIN SELECT SQL_NO_CACHE * FROM employees WHERE `name` = 'name_1' OR `age` = 1\G<br />*************************** 1. row ***************************<br />           id: 1<br />  select_type: SIMPLE<br />        table: employees<br />         type: ALL<br />possible_keys: index_name,index_age<br />          key: NULL<br />      key_len: NULL<br />          ref: NULL<br />         rows: 100000<br />        Extra: Using where<br />1 row in set (0.01 sec)</pre><br /><br />対象レコードが多いのでALLになりました。<br /><br />MySQL 5.0.32の場合：<br /><br /><pre class="code">mysql&gt; EXPLAIN SELECT SQL_NO_CACHE * FROM employees WHERE `name` = 'name_1' OR `age` = 1\G<br />*************************** 1. row ***************************<br />           id: 1<br />  select_type: SIMPLE<br />        table: employees<br />         type: index_merge<br />possible_keys: index_name,index_age<br />          key: index_name,index_age<br />      key_len: 99,5<br />          ref: NULL<br />         rows: 2749<br />        Extra: Using union(index_name,index_age); Using where<br />1 row in set (0.00 sec)</pre><br /><br />typeにindex_merge、ExtraにUsing union(index_name,index_age)と出ました。ユニオンアクセスアルゴリズムを使って別々のインデックスがマージされて使われているようです。<br /><br />実際の速度：<br /><br /><pre class="code">mysql&gt; SELECT SQL_NO_CACHE * FROM employees WHERE `name` = 'name_1' OR `age` = 1;</pre><br /><br />インデックス結合無し（MySQL 4.1.22）：0.13 sec<br />インデックス結合有り（MySQL 5.0.32）：0.02 sec<br /><br />・ソートユニオンアクセスアルゴリズム<br /><br />MySQL 4.1.22の場合：<br /><br /><pre class="code">mysql&gt; EXPLAIN SELECT SQL_NO_CACHE * FROM employees WHERE `name` = 'name_1' AND `age` &lt; 5\G<br />*************************** 1. row ***************************<br />           id: 1<br />  select_type: SIMPLE<br />        table: employees<br />         type: ref<br />possible_keys: index_name,index_age<br />          key: index_name<br />      key_len: 33<br />          ref: const<br />         rows: 571<br />        Extra: Using where<br />1 row in set (0.01 sec)</pre><br /><br />普通にインデックスが一つだけ使われました。<br /><br />MySQL 5.0.32の場合：<br /><br /><pre class="code">mysql&gt; EXPLAIN SELECT SQL_NO_CACHE * FROM employees WHERE `name` = 'name_1' OR `age` &lt; 5\G<br />*************************** 1. row ***************************<br />           id: 1<br />  select_type: SIMPLE<br />        table: employees<br />         type: index_merge<br />possible_keys: index_name,index_age<br />          key: index_name,index_age<br />      key_len: 99,5<br />          ref: NULL<br />         rows: 11537<br />        Extra: Using sort_union(index_name,index_age); Using where<br />1 row in set (0.00 sec)</pre><br /><br />typeにindex_merge、ExtraにUsing sort_union(index_name,index_age)と出ました。ソートユニオンアクセスアルゴリズムを使って別々のインデックスがマージされて使われているようです。<br /><br />実際の速度：<br /><br /><pre class="code">mysql&gt; EXPLAIN SELECT SQL_NO_CACHE * FROM employees WHERE `name` = 'name_1' OR `age` &lt; 5;</pre><br /><br />インデックス結合無し（MySQL 4.1.22）：0.15 sec<br />インデックス結合有り（MySQL 5.0.32）：0.07 sec<br /><br />大抵の場面で複数のインデックスを結合してクエリが速くなることがわかりました。これらの条件はとりたてて特殊なものではないので速くなる場面は多そうです。MySQL 5.0以上に乗り換えた再に無自覚に効果が出ているかもしれませんが、MySQL 4.1系以前とは違ってこのインデックス結合を意識したインデックス設計は大事だと思います。<br /><br />個人的にこの<strong>１テーブル１インデックス問題</strong>はずっと気になっていて、他のRDBに乗り換えようかな、などと考えていたんですが、このインデックス結合をみてMySQLで頑張ってみようという気になりました。<br /><br />※追記<br />「複合インデックスと名前が紛らわしい」、「例題が悪い」との指摘を受けました。確かにその通りだと思いました。それとPostgreSQLのEXPLAINで出てくる様なMerge自体のコストも気になるところです。追って調べていきたいと思います。
{% endraw %}
